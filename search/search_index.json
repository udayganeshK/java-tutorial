{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Java Spring Boot REST Tutorials","text":"<p>Welcome! This site provides interactive, tabbed tutorials for Java Spring Boot REST development, tailored for Angular developers.</p>"},{"location":"#featured-topics","title":"Featured Topics","text":"<ul> <li>Layered Architecture \u2014 Understanding separation of concerns with Controllers, Services, and Repositories</li> </ul> <p>Each topic features both a Concise View for quick reference and a Detailed View with in-depth explanations, code examples, and lab instructions.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Use the navigation above to explore topics. Each page includes practical examples and hands-on lab exercises.</p>"},{"location":"layered-architecture/","title":"Layered Architecture: Controllers, Services, Repositories","text":"Concise View <ul> <li>Controller: Handles HTTP requests/responses</li> <li>Service: Business logic</li> <li>Repository: Data access (DB operations)</li> <li>Promotes maintainability, testability, and separation of concerns</li> </ul> Detailed View"},{"location":"layered-architecture/#overview","title":"Overview","text":"<p>Layered architecture organizes code into logical layers, each with a specific responsibility. In Spring Boot, the most common layers are:</p> <ul> <li>Controller: Handles HTTP requests and responses</li> <li>Service: Contains business logic</li> <li>Repository: Manages data access (e.g., database operations)</li> </ul> <p>This separation improves maintainability, testability, and scalability. It also makes it easier to test and refactor code, and to assign clear responsibilities to each part of your application.</p>"},{"location":"layered-architecture/#structure-example","title":"Structure Example","text":"<pre><code>com.example.demo\n\u251c\u2500\u2500 controller\n\u2502   \u2514\u2500\u2500 BookController.java\n\u251c\u2500\u2500 service\n\u2502   \u2514\u2500\u2500 BookService.java\n\u2514\u2500\u2500 repository\n    \u2514\u2500\u2500 BookRepository.java\n</code></pre>"},{"location":"layered-architecture/#code-example","title":"Code Example","text":"<p>BookController.java <pre><code>@RestController\n@RequestMapping(\"/api/books\")\npublic class BookController {\n    @Autowired\n    private BookService bookService;\n\n    @GetMapping\n    public List&lt;BookDTO&gt; getAllBooks() {\n        return bookService.getAllBooks();\n    }\n}\n</code></pre></p> <p>BookService.java <pre><code>@Service\npublic class BookService {\n    @Autowired\n    private BookRepository bookRepository;\n\n    public List&lt;BookDTO&gt; getAllBooks() {\n        // business logic, mapping, etc.\n        return ...;\n    }\n}\n</code></pre></p> <p>BookRepository.java <pre><code>public interface BookRepository extends JpaRepository&lt;Book, Long&gt; {}\n</code></pre></p>"},{"location":"layered-architecture/#lab-instructions","title":"Lab Instructions","text":"<ol> <li>Create a new Spring Boot project with the above structure.</li> <li>Implement a simple REST API for managing books using Controller, Service, and Repository layers.</li> <li>Add a new endpoint to fetch all books.</li> <li>(Optional) Add endpoints for creating, updating, and deleting books.</li> </ol>"},{"location":"layered-architecture/#angular-perspective","title":"Angular Perspective","text":"<ul> <li>Similar to Angular's separation of concerns: Components (UI), Services (logic), and HttpClient (data access).</li> <li>Promotes modular, testable code in both frontend and backend.</li> </ul>"},{"location":"layered-architecture/#further-reading","title":"Further Reading","text":"<ul> <li>Spring Boot Reference Documentation</li> <li>Layered Architecture Pattern</li> </ul>"},{"location":"topics/dependency-injection/","title":"Dependency Injection in Spring Boot &amp; Angular","text":"Concise View <p>What is Dependency Injection (DI)?</p> <p>Dependency Injection is a design pattern that allows you to inject required objects (dependencies) into a class, rather than creating them inside the class. This promotes loose coupling, testability, and maintainability.</p> <p>Spring Boot: Uses annotations like <code>@Autowired</code>, <code>@Service</code>, <code>@Component</code>, and constructor injection for DI.</p> <p>Angular: Uses decorators like <code>@Injectable</code>, <code>@Component</code>, and the Angular DI system to provide dependencies.</p> <p>Goal: Decouple class logic from the creation of dependencies, making code easier to test and extend.</p> Detailed View"},{"location":"topics/dependency-injection/#why-use-dependency-injection","title":"Why Use Dependency Injection?","text":"<ul> <li>Promotes loose coupling between classes</li> <li>Makes unit testing easier (mock dependencies)</li> <li>Centralizes configuration and object creation</li> <li>Encourages best practices for maintainable code</li> </ul>"},{"location":"topics/dependency-injection/#spring-boot-example","title":"Spring Boot Example","text":"<p>Service Injection (Constructor-based, recommended): <pre><code>@Service\npublic class BookService {\n    private final BookRepository repository;\n\n    // Constructor injection (preferred)\n    public BookService(BookRepository repository) {\n        this.repository = repository;\n    }\n}\n</code></pre></p> <p>Legacy Field Injection (not recommended): <pre><code>@Service\npublic class BookService {\n    @Autowired\n    private BookRepository repository;\n}\n</code></pre></p> <p>Component Scanning: - <code>@Component</code>, <code>@Service</code>, <code>@Repository</code>, and <code>@Controller</code> are detected and managed by Spring\u2019s IoC container.</p>"},{"location":"topics/dependency-injection/#angular-example","title":"Angular Example","text":"<p>Service Injection: <pre><code>@Injectable({ providedIn: 'root' })\nexport class BookService {\n  constructor(private http: HttpClient) {}\n}\n</code></pre></p> <p>Component Injection: <pre><code>@Component({\n  selector: 'app-book-list',\n  templateUrl: './book-list.component.html'\n})\nexport class BookListComponent {\n  constructor(private bookService: BookService) {}\n}\n</code></pre></p>"},{"location":"topics/dependency-injection/#comparison-table","title":"Comparison Table","text":"Aspect Spring Boot (Java) Angular (TypeScript) Registration @Component, @Service, etc. @Injectable, @Component Injection Style Constructor, field, setter Constructor Scope Singleton (default) Singleton (default) Testability Easy with mocks Easy with TestBed/mocks"},{"location":"topics/dependency-injection/#best-practices","title":"Best Practices","text":"<ul> <li>Prefer constructor injection (both frameworks)</li> <li>Avoid field injection in Spring Boot</li> <li>Use <code>providedIn: 'root'</code> for Angular services unless you need a different scope</li> <li>Use interfaces for easier mocking and testing</li> </ul>"},{"location":"topics/dependency-injection/#further-reading","title":"Further Reading","text":"<ul> <li>Spring Boot DI Docs</li> <li>Angular Dependency Injection</li> </ul>"},{"location":"topics/layered-architecture/","title":"Layered Architecture \ud83d\uddc2\ufe0f","text":"Jump to: Concise View | Detailed View Concise Overview \ud83d\udcdd <p>What is Layered Architecture?</p> <p>Layered architecture is a design pattern that organizes your application into logical layers, each with a clear responsibility. It's the most common pattern for Java REST APIs using Spring Boot.</p> \ud83d\udd17 Controller Layer Handles HTTP requests and responses, maps endpoints, and delegates work to the service layer. \u2699\ufe0f Service Layer Contains business logic, validation, and orchestration of data. \ud83d\udcbe Repository Layer Manages data access, such as database operations. <p>Key Benefits:</p> <p>Quick Example: <pre><code>// Controller\n@RestController\n@RequestMapping(\"/api/books\")\npublic class BookController {\n    @Autowired\n    private BookService bookService;\n    // ...\n}\n\n// Service\n@Service\npublic class BookService {\n    @Autowired\n    private BookRepository bookRepository;\n    // ...\n}\n\n// Repository\n@Repository\npublic class BookRepository {\n    // ...\n}\n</code></pre></p>"},{"location":"topics/layered-architecture/#layered-architecture-in-spring-boot","title":"Layered Architecture in Spring Boot","text":"Concise View <p>Controller: The Entry Point. Handles HTTP routing and Request/Response mapping. Service: The Brain. Orchestrates business logic, transactions, and security. Repository: The Data Gateway. Abstracts SQL/NoSQL operations using Spring Data JPA. Goal: Decouple logic from infrastructure to ensure your code doesn't become a \"Big Ball of Mud.\"</p> Detailed View"},{"location":"topics/layered-architecture/#why-layers","title":"Why Layers?","text":"<p>In the Java ecosystem, we follow the Principle of Single Responsibility. By isolating the database logic from the REST logic, we can swap a MySQL database for MongoDB without ever touching our REST Controller.</p>"},{"location":"topics/layered-architecture/#the-angular-developer-mental-map","title":"The \"Angular Developer\" Mental Map","text":"Java Layer Angular Equivalent Responsibility Controller Component / Route Receiving the \"event\" (HTTP call) and returning a View/Data Service Service (@Injectable) Calculating data, handling state, and sharing logic Repository HttpClient + Store Interacting with the external data source (the DB) DTO/Entity Interface / Model Defining the shape of the data"},{"location":"topics/layered-architecture/#implementation-example","title":"Implementation Example","text":"<p>We\u2019ll use a Book Management system. Notice the use of <code>@RequiredArgsConstructor</code>\u2014it's the modern Java way to do Dependency Injection (instead of the older <code>@Autowired</code> on fields).</p> <p>1. The Controller (The API Surface) <pre><code>@RestController\n@RequestMapping(\"/api/v1/books\")\n@RequiredArgsConstructor \npublic class BookController {\n        private final BookService bookService; // Final fields + RequiredArgsConstructor = Clean DI\n\n        @GetMapping\n        public ResponseEntity&lt;List&lt;BookResponse&gt;&gt; getAllBooks() {\n                return ResponseEntity.ok(bookService.fetchAllBooks());\n        }\n}\n</code></pre></p> <p>2. The Service (Business Logic) <pre><code>@Service\n@RequiredArgsConstructor\npublic class BookService {\n        private final BookRepository repository;\n\n        @Transactional(readOnly = true)\n        public List&lt;BookResponse&gt; fetchAllBooks() {\n                return repository.findAll().stream()\n                                .map(book -&gt; new BookResponse(book.getId(), book.getTitle()))\n                                .toList(); // Java 17+ syntax\n        }\n}\n</code></pre></p> <p>3. The Repository (Data Access) <pre><code>@Repository\npublic interface BookRepository extends JpaRepository&lt;BookEntity, Long&gt; {\n        // You get CRUD for free! No implementation code needed.\n}\n</code></pre></p>"},{"location":"topics/layered-architecture/#lab-instructions-the-migration","title":"Lab Instructions: \"The Migration\"","text":"<ol> <li>Generate: Use start.spring.io to bootstrap a project with Spring Web and Spring Data JPA.</li> <li>Model: Create a Book entity with id, title, and author.</li> <li>Bridge: Create the Repository interface.</li> <li>Process: Implement a Service method that filters books by author name.</li> <li>Expose: Create a GET endpoint in the Controller that accepts a <code>@RequestParam</code>.</li> </ol> <p>Pro Tip for Angular Devs: In Java, we use DTOs (Data Transfer Objects) to send data to the frontend. Never expose your Database Entity directly to your Angular HttpClient! It\u2019s like sending your internal private class members over the wire.</p>"},{"location":"topics/layered-architecture/#reference-comparison","title":"Reference Comparison","text":"<ul> <li>Spring Boot: Uses Annotations (<code>@Service</code>, <code>@RestController</code>) for Metadata.</li> <li>Angular: Uses Decorators (<code>@Component</code>, <code>@Injectable</code>) for Metadata.</li> </ul> <p>When to Use:</p> <ul> <li>Most RESTful APIs and CRUD applications</li> <li>Projects where maintainability and testability are priorities</li> </ul> <p>Compare:</p> <ul> <li>Easier to understand than Hexagonal or Microkernel architectures</li> </ul> <p>Real-World Example:</p> <p>Online bookstores, banking apps, and ticketing systems often use this pattern for their backend APIs.</p> Detailed Guide \ud83d\udcda <p>Why Use Layered Architecture?</p> <ul> <li>Separation of Concerns: Each layer has a single responsibility, making code easier to manage.</li> <li>Testability: You can test each layer independently using mocks or stubs.</li> <li>Maintainability: Changes in one layer (e.g., switching databases) have minimal impact on others.</li> <li>Scalability: Layers can be scaled or replaced independently.</li> </ul>"},{"location":"topics/layered-architecture/#typical-structure","title":"Typical Structure","text":"<pre><code>com.example.demo\n\u251c\u2500\u2500 controller\n\u2502   \u2514\u2500\u2500 BookController.java\n\u251c\u2500\u2500 service\n\u2502   \u2514\u2500\u2500 BookService.java\n\u2514\u2500\u2500 repository\n    \u2514\u2500\u2500 BookRepository.java\n</code></pre>"},{"location":"topics/layered-architecture/#example-book-api","title":"Example: Book API","text":"<p>BookController.java <pre><code>@RestController\n@RequestMapping(\"/api/books\")\npublic class BookController {\n    @Autowired\n    private BookService bookService;\n\n    @GetMapping\n    public List&lt;Book&gt; getAllBooks() {\n        return bookService.getAllBooks();\n    }\n}\n</code></pre></p> <p>BookService.java <pre><code>@Service\npublic class BookService {\n    @Autowired\n    private BookRepository bookRepository;\n\n    public List&lt;Book&gt; getAllBooks() {\n        return bookRepository.findAll();\n    }\n}\n</code></pre></p> <p>BookRepository.java <pre><code>@Repository\npublic class BookRepository {\n    public List&lt;Book&gt; findAll() {\n        // Imagine this connects to a database\n        return List.of(new Book(\"Java 101\"), new Book(\"Spring Boot in Action\"));\n    }\n}\n</code></pre></p>"},{"location":"topics/layered-architecture/#real-world-use-case","title":"Real-World Use Case","text":"<p>Suppose you\u2019re building an online bookstore. The controller handles HTTP requests for books, the service layer contains business rules (e.g., discounts, stock checks), and the repository interacts with the database.</p>"},{"location":"topics/layered-architecture/#comparison-with-other-architectures","title":"Comparison with Other Architectures","text":"Architecture Pros Cons Layered Simple, maintainable, testable Can become rigid for large systems Hexagonal Flexible, good for integrations More complex, steeper learning curve Microkernel Great for plugin-based systems Overkill for most REST APIs"},{"location":"topics/layered-architecture/#best-practices","title":"Best Practices","text":"<ul> <li>Keep controllers thin\u2014move logic to services.</li> <li>Use interfaces for services and repositories for easier testing.</li> <li>Avoid direct database access in controllers or services.</li> </ul>"},{"location":"topics/layered-architecture/#further-reading","title":"Further Reading","text":"<ul> <li>Spring Boot Reference Documentation</li> <li>Martin Fowler: Patterns of Enterprise Application Architecture</li> </ul>"},{"location":"topics/layered-architecture/#code-example","title":"Code Example","text":"<p>BookController.java <pre><code>@RestController\n@RequestMapping(\"/api/books\")\npublic class BookController {\n    @Autowired\n    private BookService bookService;\n\n    @GetMapping\n    public List&lt;Book&gt; getAllBooks() {\n        return bookService.getAllBooks();\n    }\n}\n</code></pre></p> <p>BookService.java <pre><code>@Service\npublic class BookService {\n    @Autowired\n    private BookRepository bookRepository;\n\n    public List&lt;Book&gt; getAllBooks() {\n        return bookRepository.findAll();\n    }\n}\n</code></pre></p> <p>BookRepository.java <pre><code>@Repository\npublic class BookRepository {\n    public List&lt;Book&gt; findAll() {\n        // Imagine this connects to a database\n        return List.of(new Book(\"Java 101\"), new Book(\"Spring Boot in Action\"));\n    }\n}\n</code></pre></p>"},{"location":"topics/layered-architecture/#real-world-use-case_1","title":"Real-World Use Case","text":"<p>Suppose you\u2019re building an online bookstore. The controller handles HTTP requests for books, the service layer contains business rules (e.g., discounts, stock checks), and the repository interacts with the database.</p>"},{"location":"topics/layered-architecture/#comparison-with-other-architectures_1","title":"Comparison with Other Architectures","text":"<ul> <li>Hexagonal (Ports &amp; Adapters): More flexible for complex integrations, but harder to grasp for beginners.</li> <li>Microkernel: Good for plugin-based systems, but overkill for most REST APIs.</li> <li>Layered: Easiest to start with, especially for CRUD and RESTful services.</li> </ul>"},{"location":"topics/layered-architecture/#best-practices_1","title":"Best Practices","text":"<ul> <li>Keep controllers thin\u2014move logic to services.</li> <li>Use interfaces for services and repositories for easier testing.</li> <li>Avoid direct database access in controllers or services.</li> </ul>"},{"location":"topics/layered-architecture/#further-reading_1","title":"Further Reading","text":"<ul> <li>Spring Boot Reference Documentation</li> <li> <p>Martin Fowler: Patterns of Enterprise Application Architecture</p> <pre><code>@GetMapping\npublic List&lt;BookDTO&gt; getAllBooks() {\n    return bookService.getAllBooks();\n}\n</code></pre> <p>} <code>**BookService.java**</code>java @Service public class BookService {     @Autowired     private BookRepository bookRepository;      public List getAllBooks() {         // business logic, mapping, etc.         return ...;     } } ``` <p>BookRepository.java <pre><code>public interface BookRepository extends JpaRepository&lt;Book, Long&gt; {}\n</code></pre></p>"},{"location":"topics/layered-architecture/#lab-instructions","title":"Lab Instructions","text":"<ol> <li>Create a new Spring Boot project with the above structure.</li> <li>Implement a simple REST API for managing books using Controller, Service, and Repository layers.</li> <li>Add a new endpoint to fetch all books.</li> <li>(Optional) Add endpoints for creating, updating, and deleting books.</li> </ol>"},{"location":"topics/layered-architecture/#angular-perspective","title":"Angular Perspective","text":"<ul> <li>Similar to Angular's separation of concerns: Components (UI), Services (logic), and HttpClient (data access).</li> <li>Promotes modular, testable code in both frontend and backend.</li> </ul>"},{"location":"topics/layered-architecture/#further-reading_2","title":"Further Reading","text":"<ul> <li>Spring Boot Reference Documentation</li> <li>Layered Architecture Pattern</li> </ul>"}]}