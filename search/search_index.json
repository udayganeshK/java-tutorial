{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Java Spring Boot REST Tutorials","text":"<p>Welcome! This site provides interactive, tabbed tutorials for Java Spring Boot REST development, tailored for Angular developers.</p>"},{"location":"#featured-topics","title":"Featured Topics","text":"<ul> <li>Layered Architecture \u2014 Understanding separation of concerns with Controllers, Services, and Repositories</li> </ul> <p>Each topic features both a Concise View for quick reference and a Detailed View with in-depth explanations, code examples, and lab instructions.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Use the navigation above to explore topics. Each page includes practical examples and hands-on lab exercises.</p>"},{"location":"layered-architecture/","title":"Layered Architecture: Controllers, Services, Repositories","text":"Concise View <ul> <li>Controller: Handles HTTP requests/responses</li> <li>Service: Business logic</li> <li>Repository: Data access (DB operations)</li> <li>Promotes maintainability, testability, and separation of concerns</li> </ul> Detailed View"},{"location":"layered-architecture/#overview","title":"Overview","text":"<p>Layered architecture organizes code into logical layers, each with a specific responsibility. In Spring Boot, the most common layers are:</p> <ul> <li>Controller: Handles HTTP requests and responses</li> <li>Service: Contains business logic</li> <li>Repository: Manages data access (e.g., database operations)</li> </ul> <p>This separation improves maintainability, testability, and scalability. It also makes it easier to test and refactor code, and to assign clear responsibilities to each part of your application.</p>"},{"location":"layered-architecture/#structure-example","title":"Structure Example","text":"<pre><code>com.example.demo\n\u251c\u2500\u2500 controller\n\u2502   \u2514\u2500\u2500 BookController.java\n\u251c\u2500\u2500 service\n\u2502   \u2514\u2500\u2500 BookService.java\n\u2514\u2500\u2500 repository\n    \u2514\u2500\u2500 BookRepository.java\n</code></pre>"},{"location":"layered-architecture/#code-example","title":"Code Example","text":"<p>BookController.java <pre><code>@RestController\n@RequestMapping(\"/api/books\")\npublic class BookController {\n    @Autowired\n    private BookService bookService;\n\n    @GetMapping\n    public List&lt;BookDTO&gt; getAllBooks() {\n        return bookService.getAllBooks();\n    }\n}\n</code></pre></p> <p>BookService.java <pre><code>@Service\npublic class BookService {\n    @Autowired\n    private BookRepository bookRepository;\n\n    public List&lt;BookDTO&gt; getAllBooks() {\n        // business logic, mapping, etc.\n        return ...;\n    }\n}\n</code></pre></p> <p>BookRepository.java <pre><code>public interface BookRepository extends JpaRepository&lt;Book, Long&gt; {}\n</code></pre></p>"},{"location":"layered-architecture/#lab-instructions","title":"Lab Instructions","text":"<ol> <li>Create a new Spring Boot project with the above structure.</li> <li>Implement a simple REST API for managing books using Controller, Service, and Repository layers.</li> <li>Add a new endpoint to fetch all books.</li> <li>(Optional) Add endpoints for creating, updating, and deleting books.</li> </ol>"},{"location":"layered-architecture/#angular-perspective","title":"Angular Perspective","text":"<ul> <li>Similar to Angular's separation of concerns: Components (UI), Services (logic), and HttpClient (data access).</li> <li>Promotes modular, testable code in both frontend and backend.</li> </ul>"},{"location":"layered-architecture/#further-reading","title":"Further Reading","text":"<ul> <li>Spring Boot Reference Documentation</li> <li>Layered Architecture Pattern</li> </ul>"},{"location":"topics/layered-architecture/","title":"Layered Architecture \ud83d\uddc2\ufe0f","text":"Concise Overview \ud83d\udcdd <p>What is Layered Architecture?</p> <p>Layered architecture is a design pattern that organizes your application into logical layers, each with a clear responsibility. It's the most common pattern for Java REST APIs using Spring Boot.</p> \ud83d\udd17 Controller Layer Handles HTTP requests and responses, maps endpoints, and delegates work to the service layer. \u2699\ufe0f Service Layer Contains business logic, validation, and orchestration of data. \ud83d\udcbe Repository Layer Manages data access, such as database operations. <p>Key Benefits:</p> <ul> <li>\ud83e\udde9 Clear separation of concerns</li> <li>\ud83e\uddea Easier to test and maintain</li> <li>\ud83d\ude80 Promotes code reuse and scalability</li> </ul> <p>Quick Example: <pre><code>// Controller\n@RestController\n@RequestMapping(\"/api/books\")\npublic class BookController {\n    @Autowired\n    private BookService bookService;\n    // ...\n}\n\n// Service\n@Service\npublic class BookService {\n    @Autowired\n    private BookRepository bookRepository;\n    // ...\n}\n\n// Repository\n@Repository\npublic class BookRepository {\n    // ...\n}\n</code></pre></p> <p>When to Use:</p> <ul> <li>Most RESTful APIs and CRUD applications</li> <li>Projects where maintainability and testability are priorities</li> </ul> <p>Compare:</p> <ul> <li>Easier to understand than Hexagonal or Microkernel architectures</li> </ul> <p>Real-World Example:</p> <p>Online bookstores, banking apps, and ticketing systems often use this pattern for their backend APIs.</p> Detailed Guide \ud83d\udcda <p>Why Use Layered Architecture?</p> <ul> <li>Separation of Concerns: Each layer has a single responsibility, making code easier to manage.</li> <li>Testability: You can test each layer independently using mocks or stubs.</li> <li>Maintainability: Changes in one layer (e.g., switching databases) have minimal impact on others.</li> <li>Scalability: Layers can be scaled or replaced independently.</li> </ul>"},{"location":"topics/layered-architecture/#typical-structure","title":"Typical Structure","text":"<pre><code>com.example.demo\n\u251c\u2500\u2500 controller\n\u2502   \u2514\u2500\u2500 BookController.java\n\u251c\u2500\u2500 service\n\u2502   \u2514\u2500\u2500 BookService.java\n\u2514\u2500\u2500 repository\n    \u2514\u2500\u2500 BookRepository.java\n</code></pre>"},{"location":"topics/layered-architecture/#example-book-api","title":"Example: Book API","text":"<p>BookController.java <pre><code>@RestController\n@RequestMapping(\"/api/books\")\npublic class BookController {\n    @Autowired\n    private BookService bookService;\n\n    @GetMapping\n    public List&lt;Book&gt; getAllBooks() {\n        return bookService.getAllBooks();\n    }\n}\n</code></pre></p> <p>BookService.java <pre><code>@Service\npublic class BookService {\n    @Autowired\n    private BookRepository bookRepository;\n\n    public List&lt;Book&gt; getAllBooks() {\n        return bookRepository.findAll();\n    }\n}\n</code></pre></p> <p>BookRepository.java <pre><code>@Repository\npublic class BookRepository {\n    public List&lt;Book&gt; findAll() {\n        // Imagine this connects to a database\n        return List.of(new Book(\"Java 101\"), new Book(\"Spring Boot in Action\"));\n    }\n}\n</code></pre></p>"},{"location":"topics/layered-architecture/#real-world-use-case","title":"Real-World Use Case","text":"<p>Suppose you\u2019re building an online bookstore. The controller handles HTTP requests for books, the service layer contains business rules (e.g., discounts, stock checks), and the repository interacts with the database.</p>"},{"location":"topics/layered-architecture/#comparison-with-other-architectures","title":"Comparison with Other Architectures","text":"Architecture Pros Cons Layered Simple, maintainable, testable Can become rigid for large systems Hexagonal Flexible, good for integrations More complex, steeper learning curve Microkernel Great for plugin-based systems Overkill for most REST APIs"},{"location":"topics/layered-architecture/#best-practices","title":"Best Practices","text":"<ul> <li>Keep controllers thin\u2014move logic to services.</li> <li>Use interfaces for services and repositories for easier testing.</li> <li>Avoid direct database access in controllers or services.</li> </ul>"},{"location":"topics/layered-architecture/#further-reading","title":"Further Reading","text":"<ul> <li>Spring Boot Reference Documentation</li> <li>Martin Fowler: Patterns of Enterprise Application Architecture</li> </ul>"},{"location":"topics/layered-architecture/#code-example","title":"Code Example","text":"<p>BookController.java <pre><code>@RestController\n@RequestMapping(\"/api/books\")\npublic class BookController {\n    @Autowired\n    private BookService bookService;\n\n    @GetMapping\n    public List&lt;Book&gt; getAllBooks() {\n        return bookService.getAllBooks();\n    }\n}\n</code></pre></p> <p>BookService.java <pre><code>@Service\npublic class BookService {\n    @Autowired\n    private BookRepository bookRepository;\n\n    public List&lt;Book&gt; getAllBooks() {\n        return bookRepository.findAll();\n    }\n}\n</code></pre></p> <p>BookRepository.java <pre><code>@Repository\npublic class BookRepository {\n    public List&lt;Book&gt; findAll() {\n        // Imagine this connects to a database\n        return List.of(new Book(\"Java 101\"), new Book(\"Spring Boot in Action\"));\n    }\n}\n</code></pre></p>"},{"location":"topics/layered-architecture/#real-world-use-case_1","title":"Real-World Use Case","text":"<p>Suppose you\u2019re building an online bookstore. The controller handles HTTP requests for books, the service layer contains business rules (e.g., discounts, stock checks), and the repository interacts with the database.</p>"},{"location":"topics/layered-architecture/#comparison-with-other-architectures_1","title":"Comparison with Other Architectures","text":"<ul> <li>Hexagonal (Ports &amp; Adapters): More flexible for complex integrations, but harder to grasp for beginners.</li> <li>Microkernel: Good for plugin-based systems, but overkill for most REST APIs.</li> <li>Layered: Easiest to start with, especially for CRUD and RESTful services.</li> </ul>"},{"location":"topics/layered-architecture/#best-practices_1","title":"Best Practices","text":"<ul> <li>Keep controllers thin\u2014move logic to services.</li> <li>Use interfaces for services and repositories for easier testing.</li> <li>Avoid direct database access in controllers or services.</li> </ul>"},{"location":"topics/layered-architecture/#further-reading_1","title":"Further Reading","text":"<ul> <li>Spring Boot Reference Documentation</li> <li> <p>Martin Fowler: Patterns of Enterprise Application Architecture</p> <pre><code>@GetMapping\npublic List&lt;BookDTO&gt; getAllBooks() {\n    return bookService.getAllBooks();\n}\n</code></pre> <p>} <code>**BookService.java**</code>java @Service public class BookService {     @Autowired     private BookRepository bookRepository;      public List getAllBooks() {         // business logic, mapping, etc.         return ...;     } } ``` <p>BookRepository.java <pre><code>public interface BookRepository extends JpaRepository&lt;Book, Long&gt; {}\n</code></pre></p>"},{"location":"topics/layered-architecture/#lab-instructions","title":"Lab Instructions","text":"<ol> <li>Create a new Spring Boot project with the above structure.</li> <li>Implement a simple REST API for managing books using Controller, Service, and Repository layers.</li> <li>Add a new endpoint to fetch all books.</li> <li>(Optional) Add endpoints for creating, updating, and deleting books.</li> </ol>"},{"location":"topics/layered-architecture/#angular-perspective","title":"Angular Perspective","text":"<ul> <li>Similar to Angular's separation of concerns: Components (UI), Services (logic), and HttpClient (data access).</li> <li>Promotes modular, testable code in both frontend and backend.</li> </ul>"},{"location":"topics/layered-architecture/#further-reading_2","title":"Further Reading","text":"<ul> <li>Spring Boot Reference Documentation</li> <li>Layered Architecture Pattern</li> </ul>"}]}