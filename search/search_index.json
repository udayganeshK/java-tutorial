{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Java Spring Boot REST Tutorials","text":"<p>Welcome! This site provides interactive, tabbed tutorials for Java Spring Boot REST development, tailored for Angular developers.</p>"},{"location":"#featured-topics","title":"Featured Topics","text":"<ul> <li>Layered Architecture \u2014 Understanding separation of concerns with Controllers, Services, and Repositories</li> </ul> <p>Each topic features both a Concise View for quick reference and a Detailed View with in-depth explanations, code examples, and lab instructions.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Use the navigation above to explore topics. Each page includes practical examples and hands-on lab exercises.</p>"},{"location":"layered-architecture/","title":"Layered Architecture: Controllers, Services, Repositories","text":"Concise View <ul> <li>Controller: Handles HTTP requests/responses</li> <li>Service: Business logic</li> <li>Repository: Data access (DB operations)</li> <li>Promotes maintainability, testability, and separation of concerns</li> </ul> Detailed View"},{"location":"layered-architecture/#overview","title":"Overview","text":"<p>Layered architecture organizes code into logical layers, each with a specific responsibility. In Spring Boot, the most common layers are:</p> <ul> <li>Controller: Handles HTTP requests and responses</li> <li>Service: Contains business logic</li> <li>Repository: Manages data access (e.g., database operations)</li> </ul> <p>This separation improves maintainability, testability, and scalability. It also makes it easier to test and refactor code, and to assign clear responsibilities to each part of your application.</p>"},{"location":"layered-architecture/#structure-example","title":"Structure Example","text":"<pre><code>com.example.demo\n\u251c\u2500\u2500 controller\n\u2502   \u2514\u2500\u2500 BookController.java\n\u251c\u2500\u2500 service\n\u2502   \u2514\u2500\u2500 BookService.java\n\u2514\u2500\u2500 repository\n    \u2514\u2500\u2500 BookRepository.java\n</code></pre>"},{"location":"layered-architecture/#code-example","title":"Code Example","text":"<p>BookController.java <pre><code>@RestController\n@RequestMapping(\"/api/books\")\npublic class BookController {\n    @Autowired\n    private BookService bookService;\n\n    @GetMapping\n    public List&lt;BookDTO&gt; getAllBooks() {\n        return bookService.getAllBooks();\n    }\n}\n</code></pre></p> <p>BookService.java <pre><code>@Service\npublic class BookService {\n    @Autowired\n    private BookRepository bookRepository;\n\n    public List&lt;BookDTO&gt; getAllBooks() {\n        // business logic, mapping, etc.\n        return ...;\n    }\n}\n</code></pre></p> <p>BookRepository.java <pre><code>public interface BookRepository extends JpaRepository&lt;Book, Long&gt; {}\n</code></pre></p>"},{"location":"layered-architecture/#lab-instructions","title":"Lab Instructions","text":"<ol> <li>Create a new Spring Boot project with the above structure.</li> <li>Implement a simple REST API for managing books using Controller, Service, and Repository layers.</li> <li>Add a new endpoint to fetch all books.</li> <li>(Optional) Add endpoints for creating, updating, and deleting books.</li> </ol>"},{"location":"layered-architecture/#angular-perspective","title":"Angular Perspective","text":"<ul> <li>Similar to Angular's separation of concerns: Components (UI), Services (logic), and HttpClient (data access).</li> <li>Promotes modular, testable code in both frontend and backend.</li> </ul>"},{"location":"layered-architecture/#further-reading","title":"Further Reading","text":"<ul> <li>Spring Boot Reference Documentation</li> <li>Layered Architecture Pattern</li> </ul>"},{"location":"topics/dependency-injection/","title":"Dependency Injection in Spring Boot &amp; Angular","text":"Concise View <p>What is Dependency Injection (DI)?</p> <p>Dependency Injection is a design pattern that allows you to inject required objects (dependencies) into a class, rather than creating them inside the class. This promotes loose coupling, testability, and maintainability.</p> <p>Spring Boot: Uses annotations like <code>@Autowired</code>, <code>@Service</code>, <code>@Component</code>, and constructor injection for DI.</p> <p>Angular: Uses decorators like <code>@Injectable</code>, <code>@Component</code>, and the Angular DI system to provide dependencies.</p> <p>Goal: Decouple class logic from the creation of dependencies, making code easier to test and extend.</p> Detailed View"},{"location":"topics/dependency-injection/#why-use-dependency-injection","title":"Why Use Dependency Injection?","text":"<ul> <li>Promotes loose coupling between classes</li> <li>Makes unit testing easier (mock dependencies)</li> <li>Centralizes configuration and object creation</li> <li>Encourages best practices for maintainable code</li> </ul>"},{"location":"topics/dependency-injection/#spring-boot-example","title":"Spring Boot Example","text":"<p>Service Injection (Constructor-based, recommended): <pre><code>@Service\npublic class BookService {\n    private final BookRepository repository;\n\n    // Constructor injection (preferred)\n    public BookService(BookRepository repository) {\n        this.repository = repository;\n    }\n}\n</code></pre></p> <p>Legacy Field Injection (not recommended): <pre><code>@Service\npublic class BookService {\n    @Autowired\n    private BookRepository repository;\n}\n</code></pre></p> <p>Component Scanning: - <code>@Component</code>, <code>@Service</code>, <code>@Repository</code>, and <code>@Controller</code> are detected and managed by Spring\u2019s IoC container.</p>"},{"location":"topics/dependency-injection/#angular-example","title":"Angular Example","text":"<p>Service Injection: <pre><code>@Injectable({ providedIn: 'root' })\nexport class BookService {\n  constructor(private http: HttpClient) {}\n}\n</code></pre></p> <p>Component Injection: <pre><code>@Component({\n  selector: 'app-book-list',\n  templateUrl: './book-list.component.html'\n})\nexport class BookListComponent {\n  constructor(private bookService: BookService) {}\n}\n</code></pre></p>"},{"location":"topics/dependency-injection/#comparison-table","title":"Comparison Table","text":"Aspect Spring Boot (Java) Angular (TypeScript) Registration @Component, @Service, etc. @Injectable, @Component Injection Style Constructor, field, setter Constructor Scope Singleton (default) Singleton (default) Testability Easy with mocks Easy with TestBed/mocks"},{"location":"topics/dependency-injection/#best-practices","title":"Best Practices","text":"<ul> <li>Prefer constructor injection (both frameworks)</li> <li>Avoid field injection in Spring Boot</li> <li>Use <code>providedIn: 'root'</code> for Angular services unless you need a different scope</li> <li>Use interfaces for easier mocking and testing</li> </ul>"},{"location":"topics/dependency-injection/#further-reading","title":"Further Reading","text":"<ul> <li>Spring Boot DI Docs</li> <li>Angular Dependency Injection</li> </ul>"},{"location":"topics/dtos-vs-entities/","title":"DTOs vs Entities in Spring Boot","text":""},{"location":"topics/dtos-vs-entities/#what-are-dtos-and-entities","title":"What are DTOs and Entities?","text":"<p>Entity: A Java class that maps directly to a database table. It represents your data persistence layer.</p> <p>DTO (Data Transfer Object): A simple Java class used to transfer data between layers (typically from server to client). It contains only the data you want to expose.</p> Aspect Entity DTO Purpose Database mapping (JPA/Hibernate) Data transfer between layers/API Exposure Internal, kept in backend Exposed to frontend via REST API Lazy Loading Supports lazy-loaded collections Always fully initialized Circular References Can cause serialization issues Prevents circular reference problems Size May contain unnecessary fields Contains only required fields"},{"location":"topics/dtos-vs-entities/#why-use-dtos","title":"Why Use DTOs?","text":""},{"location":"topics/dtos-vs-entities/#1-security","title":"1. Security","text":"<p>Never expose your database entities directly to the frontend. Your entity might contain sensitive fields you don't want to reveal.</p> <pre><code>// \u274c BAD: Exposing entity directly\n@RestController\npublic class UserController {\n    @GetMapping(\"/users/{id}\")\n    public User getUser(@PathVariable Long id) {\n        return userRepository.findById(id).orElse(null);\n    }\n}\n\n// \u2705 GOOD: Using DTO\n@RestController\npublic class UserController {\n    @GetMapping(\"/users/{id}\")\n    public UserDTO getUser(@PathVariable Long id) {\n        User user = userRepository.findById(id).orElse(null);\n        return mapToDTO(user);\n    }\n}\n</code></pre>"},{"location":"topics/dtos-vs-entities/#2-performance","title":"2. Performance","text":"<p>DTOs allow you to fetch only the fields you need, reducing database load and network bandwidth.</p> <pre><code>// Entity might have:\n@Entity\npublic class User {\n    private Long id;\n    private String username;\n    private String email;\n    private String passwordHash;  // Don't expose!\n    private List&lt;Address&gt; addresses;  // Lazy loaded\n    private List&lt;Order&gt; orders;  // Lazy loaded\n}\n\n// DTO exposes only what's needed:\npublic class UserDTO {\n    private Long id;\n    private String username;\n    private String email;\n    // No password, addresses, or orders\n}\n</code></pre>"},{"location":"topics/dtos-vs-entities/#3-flexibility","title":"3. Flexibility","text":"<p>DTOs decouple your API contract from your internal entity structure. You can change entities without breaking the API.</p> <pre><code>// Backend entity changes:\n@Entity\npublic class User {\n    private Long id;\n    private String username;\n    private String email;\n    private LocalDateTime createdAt;  // New field\n    // ... other fields\n}\n\n// DTO remains the same\u2014no API breakage\npublic class UserDTO {\n    private Long id;\n    private String username;\n    private String email;\n}\n</code></pre>"},{"location":"topics/dtos-vs-entities/#angular-perspective","title":"Angular Perspective","text":"<p>In Angular, you have a similar pattern: - Models (Interfaces/Classes): Similar to DTOs, define the shape of data you work with - HTTP Response: Exactly like a DTO\u2014only contains what the server sends - Component State: Like an entity\u2014can have extra properties not exposed to the view</p> <pre><code>// Angular DTO equivalent\nexport interface UserDTO {\n  id: number;\n  username: string;\n  email: string;\n}\n\n// In service\nthis.http.get&lt;UserDTO&gt;('/api/users/1').subscribe(user =&gt; {\n  // Type-safe data\n});\n</code></pre>"},{"location":"topics/dtos-vs-entities/#practical-example-user-management","title":"Practical Example: User Management","text":""},{"location":"topics/dtos-vs-entities/#entity","title":"Entity","text":"<pre><code>@Entity\n@Table(name = \"users\")\npublic class User {\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    private String username;\n    private String email;\n\n    @Column(name = \"password_hash\")\n    private String passwordHash;\n\n    @OneToMany(mappedBy = \"user\", fetch = FetchType.LAZY)\n    private List&lt;Order&gt; orders;\n\n    private LocalDateTime createdAt;\n    private LocalDateTime updatedAt;\n}\n</code></pre>"},{"location":"topics/dtos-vs-entities/#dto","title":"DTO","text":"<pre><code>public class UserDTO {\n    private Long id;\n    private String username;\n    private String email;\n\n    // Constructor for mapping\n    public UserDTO(User user) {\n        this.id = user.getId();\n        this.username = user.getUsername();\n        this.email = user.getEmail();\n    }\n}\n</code></pre>"},{"location":"topics/dtos-vs-entities/#controller","title":"Controller","text":"<pre><code>@RestController\n@RequestMapping(\"/api/users\")\npublic class UserController {\n    private final UserService userService;\n\n    @GetMapping(\"/{id}\")\n    public ResponseEntity&lt;UserDTO&gt; getUser(@PathVariable Long id) {\n        User user = userService.getUserById(id);\n        return ResponseEntity.ok(new UserDTO(user));\n    }\n}\n</code></pre>"},{"location":"topics/dtos-vs-entities/#best-practices","title":"Best Practices","text":"<ol> <li>Create DTOs for API responses \u2014 Never expose raw entities</li> <li>Use separate DTOs for request and response \u2014 Request DTO for POST/PUT, Response DTO for GET</li> <li>Keep DTOs lightweight \u2014 Include only necessary fields</li> <li>Map entities to DTOs early \u2014 Do it in the controller or service layer</li> <li>Avoid lazy loading issues \u2014 DTOs help prevent \"N+1\" query problems</li> </ol>"},{"location":"topics/dtos-vs-entities/#request-vs-response-dtos","title":"Request vs Response DTOs","text":"<pre><code>// Request DTO (for POST/PUT)\npublic class CreateUserRequest {\n    @NotNull\n    private String username;\n\n    @NotNull\n    @Email\n    private String email;\n\n    @NotNull\n    @Size(min = 8)\n    private String password;\n}\n\n// Response DTO (for GET)\npublic class UserResponse {\n    private Long id;\n    private String username;\n    private String email;\n    private LocalDateTime createdAt;\n}\n</code></pre>"},{"location":"topics/dtos-vs-entities/#lab-instructions","title":"Lab Instructions","text":"<ol> <li>Create a <code>Book</code> entity with fields: id, title, author, isbn, price, createdAt</li> <li>Create a <code>BookDTO</code> that exposes only: id, title, author, price</li> <li>Create a <code>CreateBookRequest</code> DTO for POST requests with validation</li> <li>Implement a <code>BookController</code> that converts entities to DTOs before responding</li> <li>Test with Postman or cURL to verify DTOs are being used</li> </ol>"},{"location":"topics/dtos-vs-entities/#further-reading","title":"Further Reading","text":"<ul> <li>DTO Pattern in Java</li> <li>Spring Framework Best Practices</li> <li>Martin Fowler: Data Transfer Object</li> </ul>"},{"location":"topics/layered-architecture/","title":"Layered Architecture in Spring Boot \ud83d\uddc2\ufe0f","text":""},{"location":"topics/layered-architecture/#what-is-layered-architecture","title":"What is Layered Architecture?","text":"<p>Layered architecture is a design pattern that organizes your application into logical layers, each with a clear responsibility. It's the most common pattern for Java REST APIs using Spring Boot.</p> Layer Responsibility Controller Handles HTTP requests and responses, maps endpoints, delegates to service Service Contains business logic, validation, orchestration of data Repository Manages data access, such as database operations"},{"location":"topics/layered-architecture/#key-benefits","title":"Key Benefits","text":"<ul> <li>\ud83e\udde9 Clear separation of concerns</li> <li>\ud83e\uddea Easier to test and maintain</li> <li>\ud83d\ude80 Promotes code reuse and scalability</li> </ul>"},{"location":"topics/layered-architecture/#why-layers","title":"Why Layers?","text":"<p>In the Java ecosystem, we follow the Principle of Single Responsibility. By isolating the database logic from the REST logic, we can swap a MySQL database for MongoDB without ever touching our REST Controller.</p>"},{"location":"topics/layered-architecture/#the-angular-developer-mental-map","title":"The \"Angular Developer\" Mental Map","text":"Java Layer Angular Equivalent Responsibility Controller Component / Route Receiving the \"event\" (HTTP call) and returning a View/Data Service Service (@Injectable) Calculating data, handling state, and sharing logic Repository HttpClient + Store Interacting with the external data source (the DB) DTO/Entity Interface / Model Defining the shape of the data"},{"location":"topics/layered-architecture/#implementation-example","title":"Implementation Example","text":"<p>We\u2019ll use a Book Management system. Notice the use of <code>@RequiredArgsConstructor</code>\u2014it's the modern Java way to do Dependency Injection (instead of the older <code>@Autowired</code> on fields).</p>"},{"location":"topics/layered-architecture/#1-the-controller-the-api-surface","title":"1. The Controller (The API Surface)","text":"<pre><code>@RestController\n@RequestMapping(\"/api/v1/books\")\n@RequiredArgsConstructor \npublic class BookController {\n    private final BookService bookService; // Final fields + RequiredArgsConstructor = Clean DI\n\n    @GetMapping\n    public ResponseEntity&lt;List&lt;BookResponse&gt;&gt; getAllBooks() {\n        return ResponseEntity.ok(bookService.fetchAllBooks());\n    }\n}\n</code></pre>"},{"location":"topics/layered-architecture/#2-the-service-business-logic","title":"2. The Service (Business Logic)","text":"<pre><code>@Service\n@RequiredArgsConstructor\npublic class BookService {\n    private final BookRepository repository;\n\n    @Transactional(readOnly = true)\n    public List&lt;BookResponse&gt; fetchAllBooks() {\n        return repository.findAll().stream()\n                .map(book -&gt; new BookResponse(book.getId(), book.getTitle()))\n                .toList(); // Java 17+ syntax\n    }\n}\n</code></pre>"},{"location":"topics/layered-architecture/#3-the-repository-data-access","title":"3. The Repository (Data Access)","text":"<pre><code>@Repository\npublic interface BookRepository extends JpaRepository&lt;BookEntity, Long&gt; {\n    // You get CRUD for free! No implementation code needed.\n}\n</code></pre>"},{"location":"topics/layered-architecture/#lab-instructions","title":"Lab Instructions","text":"<ol> <li>Create a new Spring Boot project with the above structure.</li> <li>Implement a simple REST API for managing books using Controller, Service, and Repository layers.</li> <li>Add a new endpoint to fetch all books.</li> <li>(Optional) Add endpoints for creating, updating, and deleting books.</li> </ol>"},{"location":"topics/layered-architecture/#angular-perspective","title":"Angular Perspective","text":"<ul> <li>Similar to Angular's separation of concerns: Components (UI), Services (logic), and HttpClient (data access).</li> <li>Promotes modular, testable code in both frontend and backend.</li> </ul>"},{"location":"topics/layered-architecture/#real-world-use-case","title":"Real-World Use Case","text":"<p>Suppose you\u2019re building an online bookstore. The controller handles HTTP requests for books, the service layer contains business rules (e.g., discounts, stock checks), and the repository interacts with the database.</p>"},{"location":"topics/layered-architecture/#comparison-with-other-architectures","title":"Comparison with Other Architectures","text":"Architecture Pros Cons Layered Simple, maintainable, testable Can become rigid for large systems Hexagonal Flexible, good for integrations More complex, steeper learning curve Microkernel Great for plugin-based systems Overkill for most REST APIs"},{"location":"topics/layered-architecture/#best-practices","title":"Best Practices","text":"<ul> <li>Keep controllers thin\u2014move logic to services.</li> <li>Use interfaces for services and repositories for easier testing.</li> <li>Avoid direct database access in controllers or services.</li> </ul>"},{"location":"topics/layered-architecture/#further-reading","title":"Further Reading","text":"<ul> <li>Spring Boot Reference Documentation</li> <li>Martin Fowler: Patterns of Enterprise Application Architecture</li> </ul>"}]}